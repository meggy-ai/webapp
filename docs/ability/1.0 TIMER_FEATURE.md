# Timer Feature Implementation

## Overview

Meggy now has the ability to create, manage, and monitor timers with proactive notifications. This feature includes:

- Timer creation and management (pause, resume, cancel)
- 3-minute warning before timer completion
- Completion alerts
- Audio notifications
- Real-time updates via WebSocket

## Architecture

### Backend Components

#### 1. Timer Model (`apps/chat/models.py`)

- **Status States**: active, paused, completed, cancelled
- **Fields**:
  - `name`: Timer description
  - `duration_seconds`: Total duration
  - `end_time`: When timer will complete
  - `status`: Current state
  - `paused_at`, `remaining_seconds`: For pause/resume
  - `three_minute_warning_sent`, `completion_notification_sent`: Notification tracking

- **Methods**:
  - `get_time_remaining()`: Returns seconds remaining
  - `pause()`: Pauses active timer
  - `resume()`: Resumes paused timer
  - `cancel()`: Cancels timer
  - `complete()`: Marks timer as completed

#### 2. Timer API (`apps/api/views.py`)

**Endpoints**:

- `GET /api/timers/` - List all user's timers
- `POST /api/timers/` - Create new timer
  ```json
  {
    "name": "Break time",
    "duration_seconds": 600
  }
  ```
- `GET /api/timers/active/` - Get active/paused timers
- `GET /api/timers/{id}/` - Get specific timer
- `POST /api/timers/{id}/pause/` - Pause timer
- `POST /api/timers/{id}/resume/` - Resume timer
- `POST /api/timers/{id}/cancel/` - Cancel timer
- `DELETE /api/timers/{id}/` - Delete timer

#### 3. Timer Monitoring Service (`management/commands/monitor_timers.py`)

- Management command that checks all active timers
- Sends 3-minute warning when `150 <= time_remaining <= 180`
- Marks timer complete and sends notification when `time_remaining <= 0`
- Uses WebSocket `channel_layer.group_send()` for real-time notifications

**Running manually**:

```bash
cd backend
python manage.py monitor_timers
```

**Automated monitoring**:

```bash
cd backend
python run_timer_monitor.py
```

This runs the monitor every 30 seconds.

#### 4. WebSocket Events (`apps/chat/consumers.py`)

**Event Types**:

- `timer_warning` - 3-minute warning

  ```json
  {
    "type": "timer_warning",
    "timer_id": "uuid",
    "timer_name": "Break time",
    "time_remaining": 180,
    "message": "⏰ Timer 'Break time' will complete in 3 minutes!"
  }
  ```

- `timer_completed` - Timer finished
  ```json
  {
    "type": "timer_completed",
    "timer_id": "uuid",
    "timer_name": "Break time",
    "message": "⏰ Timer 'Break time' has completed!"
  }
  ```

### Frontend Components

#### 1. Timer API Client (`lib/api.ts`)

```typescript
timersAPI.getAll();
timersAPI.getActive();
timersAPI.create({ name, duration_seconds });
timersAPI.pause(id);
timersAPI.resume(id);
timersAPI.cancel(id);
```

#### 2. TimerDisplay Component (`components/chat/TimerDisplay.tsx`)

- Shows all active/paused timers
- Live countdown with color-coding:
  - Green: > 10 minutes
  - Yellow: 3-10 minutes
  - Red: < 3 minutes
- Progress bar visualization
- Pause/Resume/Cancel buttons
- Create new timer dialog
- Auto-refreshes every second

#### 3. Chat Page Integration (`app/chat/page.tsx`)

- Clock button in header toggles timer panel
- Timer panel slides in from right side
- WebSocket handler for timer notifications:
  - Plays audio alerts
  - Shows system messages in chat
  - `playNotificationSound()` creates beep patterns:
    - Warning: 2 beeps at 800Hz
    - Completion: 3 ascending beeps (600Hz, 800Hz, 1000Hz)

## Audio Notifications

The system uses Web Audio API to generate notification sounds:

**Warning Sound** (3-minute alert):

- 2 short beeps at 800Hz
- 200ms apart

**Completion Sound**:

- 3 ascending beeps
- 600Hz → 800Hz → 1000Hz
- Creates a pleasant completion melody

No external audio files needed - sounds are synthesized in real-time.

## Usage Flow

### 1. Creating a Timer

**Via UI**:

1. Click Clock icon in header
2. Click "New Timer" button
3. Enter name and duration
4. Click "Create Timer"

**Via API**:

```bash
curl -X POST http://localhost:8000/api/timers/ \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: application/json" \
  -d '{"name": "Focus session", "duration_seconds": 1500}'
```

### 2. Managing Timers

- **Pause**: Click pause button or call `/timers/{id}/pause/`
- **Resume**: Click play button or call `/timers/{id}/resume/`
- **Cancel**: Click X button or call `/timers/{id}/cancel/`

### 3. Receiving Notifications

1. **3-Minute Warning**:
   - Triggered when timer has 150-180 seconds left
   - Plays 2-beep warning sound
   - Shows system message in chat
   - Sent once per timer

2. **Completion**:
   - Triggered when timer reaches 0
   - Plays 3-beep completion sound
   - Shows system message in chat
   - Timer marked as completed

## Testing

### Manual Testing

1. Start backend server:

   ```bash
   cd backend
   daphne -b 0.0.0.0 -p 8000 config.asgi:application
   ```

2. Start timer monitor (in separate terminal):

   ```bash
   cd backend
   python run_timer_monitor.py
   ```

3. Start frontend:

   ```bash
   cd frontend
   npm run dev
   ```

4. Create a short timer (e.g., 4 minutes) to test:
   - 3-minute warning at 3:00
   - Completion at 0:00

### API Testing

```bash
cd backend
python test_timers.py
```

This script tests:

- Timer creation
- Status checking
- Pause/resume
- Cancellation

## Database Schema

```sql
CREATE TABLE chat_timer (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL,
    conversation_id UUID,
    name VARCHAR(200) NOT NULL,
    duration_seconds INTEGER NOT NULL,
    end_time TIMESTAMP NOT NULL,
    status VARCHAR(20) DEFAULT 'active',
    paused_at TIMESTAMP NULL,
    remaining_seconds INTEGER NULL,
    three_minute_warning_sent BOOLEAN DEFAULT FALSE,
    completion_notification_sent BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (user_id) REFERENCES accounts_user(id),
    FOREIGN KEY (conversation_id) REFERENCES chat_conversation(id)
);

CREATE INDEX idx_timer_user_status ON chat_timer(user_id, status);
CREATE INDEX idx_timer_end_time_status ON chat_timer(end_time, status);
```

## Future Enhancements

### Planned Features

1. **Natural Language Timer Creation**
   - "Set a timer for 10 minutes"
   - "Remind me in 1 hour"
   - Parse duration from chat messages

2. **Custom Notification Times**
   - User-configurable warning times
   - Multiple warnings per timer

3. **Timer Templates**
   - Pomodoro (25 min work, 5 min break)
   - Quick presets (5m, 10m, 15m, 30m, 1h)

4. **Recurring Timers**
   - Daily reminders
   - Interval-based repeats

5. **Sound Customization**
   - Upload custom alert sounds
   - Volume control
   - Silent mode

6. **Browser Notifications**
   - Desktop notifications (with permission)
   - Tab title alerts

7. **Timer History**
   - View completed timers
   - Statistics (total time tracked)

8. **Timer Categories**
   - Work, Break, Exercise, Cooking, etc.
   - Color-coded categories

## Troubleshooting

### Timer notifications not appearing

- Ensure timer monitor is running: `python run_timer_monitor.py`
- Check WebSocket connection in browser console
- Verify JWT token is valid

### Audio not playing

- Check browser audio permissions
- Ensure browser tab is not muted
- Try user gesture (click) first - some browsers block auto-play

### Timer time incorrect

- Server timezone settings in Django
- Check `TIME_ZONE` in settings
- Ensure client and server clocks are synchronized

### Monitor not checking timers

- Verify Django can connect to database
- Check channel layer configuration
- Review monitor_timers.py logs

## Configuration

### Environment Variables

```bash
# Django settings
TIME_ZONE='UTC'  # Or your timezone

# WebSocket settings (development)
CHANNEL_LAYERS = {
    'default': {
        'BACKEND': 'channels.layers.InMemoryChannelLayer'
    }
}
```

### Production Considerations

1. **Channel Layer**: Use Redis instead of InMemoryChannelLayer
2. **Timer Monitor**: Run as systemd service or with supervisor
3. **Scaling**: Consider Celery Beat for distributed task scheduling
4. **WebSocket**: Use proper ASGI server (Daphne/Uvicorn) behind nginx

## Dependencies

### Backend

- `channels==4.0.0` - WebSocket support
- `daphne==4.0.0` - ASGI server
- `djangorestframework==3.14.0` - REST API

### Frontend

- `next@16.0.10` - React framework
- `lucide-react` - Icons
- WebSocket API (built-in)
- Web Audio API (built-in)
